# Create Stable Release
#
# Manually triggered workflow to create a stable release from the main branch.
# This replaces release-please for more predictable changelog generation.
#
# VERSION SOURCE OF TRUTH: frontend/package.json
# All other version files (desktop/package.json, docusaurus/package.json,
# pyproject.toml) are updated from this source during the release process.
#
# Flow:
#   1. Validate main branch
#   2. Verify CI and Security passed
#   3. Calculate next version based on bump type
#   4. Update version files
#   5. Generate release notes from commits/PRs since last tag
#   6. Create draft release
#   7. Run release pipeline (build all → validate → publish)
#   8. Finalize release (mark non-draft)
#
# If any step fails, the release remains in draft state and nothing is published.

name: "21 Release: Stable"

on:
  workflow_dispatch:
    inputs:
      bump:
        description: "Version bump type"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch
      release_context:
        description: "Optional context to guide AI summary (e.g., 'Focus on the new Windows experience' or 'This is a bug fix release')"
        required: false
        type: string
      compare_from:
        description: "Optional commit/tag to compare from instead of last stable release (e.g., 'd6aae03' or 'v1.0.0')"
        required: false
        type: string

# Only one stable release at a time - cancel any in-progress run
concurrency:
  group: release-stable
  cancel-in-progress: true

permissions: {}

jobs:
  # ===========================================================================
  # PREPARATION
  # ===========================================================================
  check-branch:
    name: Validate Branch
    runs-on: ${{ vars.RUNNER_PROVIDER == 'namespace' && 'ubuntu-2204-x64-4x16' || 'ubuntu-latest' }}
    timeout-minutes: 5
    permissions: {}
    steps:
      - name: Require main branch
        run: |
          if [ "${{ github.ref }}" != "refs/heads/main" ]; then
            echo "::error::This workflow can ONLY run from the main branch."
            echo ""
            echo "Current branch: ${{ github.ref }}"
            echo "Required branch: refs/heads/main"
            echo ""
            echo "To create a stable release:"
            echo "1. Go to Actions -> Release: Create Stable"
            echo "2. Click 'Run workflow'"
            echo "3. Select 'main' from the branch dropdown"
            echo "4. Choose version bump type (patch/minor/major)"
            exit 1
          fi
          echo "Running on main branch"

  verify-ci:
    name: Verify CI Passed
    runs-on: ${{ vars.RUNNER_PROVIDER == 'namespace' && 'ubuntu-2204-x64-4x16' || 'ubuntu-latest' }}
    timeout-minutes: 15
    permissions:
      actions: read
    steps:
      - name: Check CI and Security workflow status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SHA="${{ github.sha }}"
          REPO="${{ github.repository }}"
          MAX_WAIT=600  # 10 minutes
          POLL_INTERVAL=30

          # Function to check a workflow's status
          check_workflow() {
            local workflow_file=$1
            local workflow_name=$2
            local waited=0

            echo "Checking $workflow_name status for commit: $SHA"

            while true; do
              RUN_INFO=$(gh api "repos/$REPO/actions/workflows/$workflow_file/runs?head_sha=$SHA&per_page=1" --jq '.workflow_runs[0] | {status: .status, conclusion: .conclusion, id: .id}' 2>/dev/null || echo "{}")

              STATUS=$(echo "$RUN_INFO" | jq -r '.status // "not_found"')
              CONCLUSION=$(echo "$RUN_INFO" | jq -r '.conclusion // "null"')
              RUN_ID=$(echo "$RUN_INFO" | jq -r '.id // "null"')

              echo "[$workflow_name] Run ID: $RUN_ID, Status: $STATUS, Conclusion: $CONCLUSION"

              if [ "$STATUS" = "completed" ] && [ "$CONCLUSION" = "success" ]; then
                echo "✅ $workflow_name passed"
                echo "✅ $workflow_name **success** for \`$SHA\` (Run ID: $RUN_ID)" >> $GITHUB_STEP_SUMMARY
                return 0
              elif [ "$STATUS" = "completed" ] && [ "$CONCLUSION" != "success" ]; then
                echo "::error::$workflow_name failed (conclusion: $CONCLUSION). Fix before creating a release."
                echo "❌ $workflow_name **$CONCLUSION** for \`$SHA\`" >> $GITHUB_STEP_SUMMARY
                return 1
              elif [ "$STATUS" = "in_progress" ] || [ "$STATUS" = "queued" ]; then
                if [ $waited -ge $MAX_WAIT ]; then
                  echo "::error::$workflow_name still running after ${MAX_WAIT}s. Aborting release."
                  echo "⏳ $workflow_name **$STATUS** - timed out after ${MAX_WAIT}s" >> $GITHUB_STEP_SUMMARY
                  return 1
                fi
                echo "⏳ $workflow_name is $STATUS, waiting ${POLL_INTERVAL}s... (${waited}s/${MAX_WAIT}s)"
                sleep $POLL_INTERVAL
                waited=$((waited + POLL_INTERVAL))
              else
                echo "::error::No $workflow_name run found for this commit."
                echo "❌ $workflow_name **not found** for \`$SHA\`" >> $GITHUB_STEP_SUMMARY
                return 1
              fi
            done
          }

          echo "### Workflow Verification" >> $GITHUB_STEP_SUMMARY

          # Check both workflows
          check_workflow "01-ci.yml" "CI" || exit 1
          check_workflow "10-security.yml" "Security" || exit 1

          echo ""
          echo "✅ All required workflows passed!"

  calculate-version:
    name: Calculate Version
    needs: [check-branch, verify-ci]
    runs-on: ${{ vars.RUNNER_PROVIDER == 'namespace' && 'ubuntu-2204-x64-4x16' || 'ubuntu-latest' }}
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      current_version: ${{ steps.version.outputs.current }}
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          ref: main
          fetch-depth: 0

      - name: Calculate next version
        id: version
        run: |
          # Get current version from package.json
          CURRENT=$(node -p "require('./frontend/package.json').version")
          echo "current=$CURRENT" >> $GITHUB_OUTPUT

          # Parse semver
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          # Bump based on input
          case "${{ inputs.bump }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          VERSION="${MAJOR}.${MINOR}.${PATCH}"
          TAG="v${VERSION}"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

          echo "### Version Bump" >> $GITHUB_STEP_SUMMARY
          echo "- **Current:** $CURRENT" >> $GITHUB_STEP_SUMMARY
          echo "- **Bump Type:** ${{ inputs.bump }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** $TAG" >> $GITHUB_STEP_SUMMARY

  update-versions:
    name: Update Version Files
    needs: calculate-version
    runs-on: ${{ vars.RUNNER_PROVIDER == 'namespace' && 'ubuntu-2204-x64-4x16' || 'ubuntu-latest' }}
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - name: Generate app token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2
        with:
          app-id: ${{ secrets.RELEASE_APP_ID }}
          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          ref: main
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Update version files
        env:
          VERSION: ${{ needs.calculate-version.outputs.version }}
          CURRENT: ${{ needs.calculate-version.outputs.current_version }}
        run: |
          # Update frontend/package.json
          jq --arg v "$VERSION" '.version = $v' frontend/package.json > tmp.json && mv tmp.json frontend/package.json

          # Update desktop/package.json
          jq --arg v "$VERSION" '.version = $v' desktop/package.json > tmp.json && mv tmp.json desktop/package.json

          # Update docusaurus/package.json
          jq --arg v "$VERSION" '.version = $v' docusaurus/package.json > tmp.json && mv tmp.json docusaurus/package.json

          # Update pyproject.toml
          sed -i "s/^version = \".*\"/version = \"$VERSION\"/" pyproject.toml

          echo "### Updated Files" >> $GITHUB_STEP_SUMMARY
          echo "- frontend/package.json: $CURRENT -> $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- desktop/package.json: -> $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- docusaurus/package.json: -> $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- pyproject.toml: -> $VERSION" >> $GITHUB_STEP_SUMMARY

      - name: Commit version bump
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add frontend/package.json desktop/package.json docusaurus/package.json pyproject.toml
          git commit -m "chore: release ${{ needs.calculate-version.outputs.version }}"
          git push

  create-draft-release:
    name: Create Draft Release
    needs: [calculate-version, update-versions]
    runs-on: ${{ vars.RUNNER_PROVIDER == 'namespace' && 'ubuntu-2204-x64-4x16' || 'ubuntu-latest' }}
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          ref: main
          fetch-depth: 0

      - name: Pull latest (after version commit)
        run: git pull origin main

      - name: Clean up orphan tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking for orphan stable tags (tags without corresponding releases)..."

          # Get all stable-looking tags (non-beta semver)
          ALL_STABLE_TAGS=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | grep -v beta || true)

          # Get all tags that have actual GitHub releases
          RELEASED_TAGS=$(gh release list --limit 100 --json tagName --jq '.[].tagName')

          ORPHAN_COUNT=0
          for tag in $ALL_STABLE_TAGS; do
            if ! echo "$RELEASED_TAGS" | grep -q "^${tag}$"; then
              echo "Deleting orphan tag: $tag"
              git push origin --delete "$tag" 2>/dev/null || true
              git tag -d "$tag" 2>/dev/null || true
              ORPHAN_COUNT=$((ORPHAN_COUNT + 1))
            fi
          done

          if [ "$ORPHAN_COUNT" -gt 0 ]; then
            echo "Cleaned up $ORPHAN_COUNT orphan tag(s)"
          else
            echo "No orphan tags found"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: scripts/release-notes-updater/package-lock.json

      - name: Install dependencies
        working-directory: scripts/release-notes-updater
        run: npm ci

      - name: Generate release notes
        env:
          MODELS_TOKEN: ${{ secrets.MODELS_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use manual compare_from if provided, otherwise find last stable release
          if [ -n "${{ inputs.compare_from }}" ]; then
            LAST_TAG="${{ inputs.compare_from }}"
            echo "Using manual compare_from: $LAST_TAG"
          else
            # Use gh release to find actual published stable releases (not orphan tags)
            LAST_TAG=$(gh release list --exclude-pre-releases --exclude-drafts --limit 1 --json tagName --jq '.[0].tagName')
            if [ -z "$LAST_TAG" ]; then
              LAST_TAG=$(git rev-list --max-parents=0 HEAD)
            fi
          fi
          NEW_TAG="${{ needs.calculate-version.outputs.tag }}"

          echo "Generating notes from $LAST_TAG to HEAD (tag: $NEW_TAG)"

          # Generate technical notes only (AI summary added after pipeline succeeds)
          npx tsx scripts/release-notes-updater/generate-notes.ts \
            --from "$LAST_TAG" \
            --to HEAD \
            --repo-url "https://github.com/${{ github.repository }}" \
            --polish \
            > /tmp/release-notes.md

      - name: Create tag
        run: |
          git tag ${{ needs.calculate-version.outputs.tag }}
          git push origin ${{ needs.calculate-version.outputs.tag }}

      - name: Create draft release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create ${{ needs.calculate-version.outputs.tag }} \
            --target main \
            --draft \
            --title "${{ needs.calculate-version.outputs.tag }}" \
            --notes-file /tmp/release-notes.md

          echo "### Draft Release Created" >> $GITHUB_STEP_SUMMARY
          echo "Created draft release: ${{ needs.calculate-version.outputs.tag }}" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # RUN RELEASE PIPELINE
  # ===========================================================================
  release-pipeline:
    name: Release Pipeline
    needs: [calculate-version, create-draft-release]
    permissions:
      contents: write
      packages: write
      deployments: write
      id-token: write  # Required for Sigstore keyless container signing
    uses: ./.github/workflows/22-release-pipeline.yml
    with:
      release_type: production
      version: ${{ needs.calculate-version.outputs.version }}
      tag: ${{ needs.calculate-version.outputs.tag }}
    secrets:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
      APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      RELEASE_APP_ID: ${{ secrets.RELEASE_APP_ID }}
      RELEASE_APP_PRIVATE_KEY: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

  # ===========================================================================
  # FINALIZE
  # ===========================================================================
  # Add AI summary to draft release (can be reviewed before publishing)
  add-ai-summary:
    name: Add AI Summary
    needs: [calculate-version, release-pipeline]
    permissions:
      contents: write
    uses: ./.github/workflows/26-ai-release-notes.yml
    with:
      tag: ${{ needs.calculate-version.outputs.tag }}
      release_context: ${{ inputs.release_context }}
      compare_from: ${{ inputs.compare_from }}
    secrets:
      MODELS_TOKEN: ${{ secrets.MODELS_TOKEN }}

  publish-release:
    name: Publish Release
    needs: [calculate-version, add-ai-summary]
    runs-on: ${{ vars.RUNNER_PROVIDER == 'namespace' && 'ubuntu-2204-x64-4x16' || 'ubuntu-latest' }}
    timeout-minutes: 5
    permissions:
      contents: write
    steps:
      - name: Generate app token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2
        with:
          app-id: ${{ secrets.RELEASE_APP_ID }}
          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

      - name: Mark release as non-draft
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          GH_REPO: ${{ github.repository }}
        run: |
          gh release edit ${{ needs.calculate-version.outputs.tag }} --draft=false

          echo "### Release Published!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release:** [${{ needs.calculate-version.outputs.tag }}](https://github.com/${{ github.repository }}/releases/tag/${{ needs.calculate-version.outputs.tag }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed to:**" >> $GITHUB_STEP_SUMMARY
          echo "- [eclosion.app](https://eclosion.app)" >> $GITHUB_STEP_SUMMARY
          echo "- Docker: \`ghcr.io/${{ github.repository }}:${{ needs.calculate-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY

  # Graduated cleanup: preserve draft release when desktop artifacts are already
  # published (the expensive ~18min build). Only do full cleanup for early failures.
  # When preserved, use "Re-run failed jobs" to retry only the failed stages.
  cleanup-on-failure:
    name: Cleanup Failed Release
    needs: [calculate-version, release-pipeline]
    if: failure()
    runs-on: ${{ vars.RUNNER_PROVIDER == 'namespace' && 'ubuntu-2204-x64-4x16' || 'ubuntu-latest' }}
    timeout-minutes: 5
    permissions:
      contents: write
    steps:
      - name: Determine cleanup strategy
        id: strategy
        run: |
          DESKTOP="${{ needs.release-pipeline.outputs.publish_desktop_result }}"
          echo "publish-desktop result: '$DESKTOP'"

          # If desktop artifacts were successfully published, preserve the draft
          # release so "Re-run failed jobs" can retry only the failed stages.
          # Empty/missing output defaults to full-cleanup (the safer path).
          if [[ "$DESKTOP" == "success" ]]; then
            echo "strategy=preserve" >> $GITHUB_OUTPUT
          else
            echo "strategy=full-cleanup" >> $GITHUB_OUTPUT
          fi

      - name: "Full cleanup: delete draft release and tag"
        if: steps.strategy.outputs.strategy == 'full-cleanup'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
        run: |
          TAG="${{ needs.calculate-version.outputs.tag }}"
          echo "Pipeline failed before desktop publish - full cleanup of $TAG"
          gh release delete "$TAG" --yes --cleanup-tag || true

          echo "### Release Failed (Full Cleanup)" >> $GITHUB_STEP_SUMMARY
          echo "Draft release $TAG has been deleted." >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs for failure details." >> $GITHUB_STEP_SUMMARY

      - name: "Preserve release: desktop artifacts already published"
        if: steps.strategy.outputs.strategy == 'preserve'
        run: |
          TAG="${{ needs.calculate-version.outputs.tag }}"
          echo "### Release Partially Failed (Draft Preserved)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Draft release **$TAG** has been preserved with desktop artifacts." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next steps:** Use **Re-run failed jobs** to retry only the failed stages." >> $GITHUB_STEP_SUMMARY

      - name: Generate app token
        if: steps.strategy.outputs.strategy == 'full-cleanup'
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2
        with:
          app-id: ${{ secrets.RELEASE_APP_ID }}
          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

      - name: Checkout for version revert
        if: steps.strategy.outputs.strategy == 'full-cleanup'
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          ref: main
          fetch-depth: 2
          token: ${{ steps.app-token.outputs.token }}

      - name: Revert version commit
        if: steps.strategy.outputs.strategy == 'full-cleanup'
        run: |
          # Check if the last commit was our version bump
          LAST_MSG=$(git log -1 --format=%s)
          if [[ "$LAST_MSG" == "chore: release"* ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git revert HEAD --no-edit
            git push
            echo "Reverted version bump commit" >> $GITHUB_STEP_SUMMARY
          fi
